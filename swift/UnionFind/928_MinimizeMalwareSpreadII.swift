//https://leetcode.com/problems/minimize-malware-spread-ii/  
class UnionFind {
      var parent: [Int]
      init(_ size: Int) {
          parent = Array<Int>(0..<size)
      }
      func find(_ node: Int) -> Int {
          guard parent[node] != node else {
              return node
          }
          var current = node
          while parent[current] != current {
              current = parent[current]
          }
          var temp = node
          while parent[temp] != current {
              (parent[temp],temp) = (current,parent[temp])
          }
          return current
      }
      func connected(_ node1: Int, _ node2: Int) -> Bool {
          return find(node1) == find(node2)
      }
      func join(_ node1: Int, _ node2: Int)  {
          parent[find(node1)] = find(node2)
      }
  }
 
 class Solution {
 
    func minMalwareSpread(_ graph: [[Int]], _ initial: [Int]) -> Int {
        let size = graph.count
        let uf = UnionFind(size)
        for r in 0..<size {
            for c in (r + 1)..<size {
                if graph[r][c] == 1 {
                    uf.join(r, c)
                }
            }
        }
        
        var compoments = Array<Int>(repeating:0, count: size)
        for node in 0..<size {
            compoments[uf.find(node)] += 1
        }
        
        var map = [Int: [Int]]()
        for node in initial {
            let p = uf.find(node)
            if nil == map[p] {
                map[p] = []
            }
            map[p]?.append(node)
        }
        
        
        
        func getInfectedNodesCountAfter( remove source: Int, _ infectedSources: [Int]) -> Int {
            
            var visited = Array<Bool>(repeating: false, count: size)
            var willInfected = Set<Int>(infectedSources)
            
            func dfs(_ root : Int) {
                for next in 0..<size {
                    if graph[root][next] == 1 && next != source && !visited[next] {
                        visited[next] = true
                        willInfected.insert(next)
                        dfs(next)
                    }
                }
            }
            
            for infectedSource in infectedSources {
                if !visited[infectedSource] && infectedSource != source {
                    visited[infectedSource] = true
                    dfs(infectedSource)
                }
            }
            return willInfected.count
        }
        
        
        var ans = (node: -1, count: Int.min)
        for (root, infectedSources) in map {
            if infectedSources.count == 1 {
                let protectCount = compoments[root] - 1
                if protectCount > ans.count {
                    ans = (infectedSources[0],protectCount)
                } else if protectCount == ans.count && ans.node > infectedSources[0] {
                    ans.node = infectedSources[0]
                }
            } else {
                for source in infectedSources {
                    
                    let protectCount = compoments[root] - getInfectedNodesCountAfter(remove: source, infectedSources)
                    if protectCount > ans.count {
                        ans = (source,protectCount)
                    } else if protectCount == ans.count && ans.node > source {
                        ans.node = source
                    }
                }
            }
        }
        
        return ans.node
    }
 }